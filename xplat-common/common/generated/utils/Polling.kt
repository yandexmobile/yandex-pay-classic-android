// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM utils/polling.ts >>>

package com.yandex.xplat.common


public enum class PollingStep(val value: String) {
    retry("retry"),
    done("done"),
    ;
    override fun toString(): String = value
}
public open class PollingError(message: String): YSError(message) {
}

public open class PollingOptions(val retries: Int?, val nextIntervalStrategy: PollingNextIntervalStrategy?, val timeoutMs: Long?, val cancellationToken: CancellationToken?) {
    companion object {
        @JvmStatic
        open fun indefinite(): PollingOptions {
            return PollingOptions(null, null, null, null)
        }

    }
}

public fun <T> startPolling(taskFn: () -> XPromise<T>, checkResult: (Result<T>) -> Result<PollingStep>, options: PollingOptions = PollingOptions.indefinite()): XPromise<T> {
    val polling = PollingFunctor(taskFn, checkResult, options)
    return polling.poll()
}

public fun <T> startSuccessResultPolling(taskFn: () -> XPromise<T>, checkResult: (T) -> Result<PollingStep>, options: PollingOptions = PollingOptions.indefinite()): XPromise<T> {
    return startPolling(taskFn,  {
        res: Result<T> ->
        res.flatMap( {
            value ->
            checkResult(value)
        })
    }
, options)
}

public open class CancellationToken() {
    private var cancelled: Boolean = false
    open fun cancel(): Unit {
        this.cancelled = true
    }

    open fun isCancelled(): Boolean {
        return this.cancelled
    }

}

public interface PollingNextIntervalStrategy {
    fun getNextIntervalMs(count: Int): Long
}

public open class PollingFixedIntervalStrategy(private val interval: Long): PollingNextIntervalStrategy {
    open override fun getNextIntervalMs(count: Int): Long {
        return this.interval
    }

}

public open class PollingIncrementalIntervalStrategy(private val interval: Long): PollingNextIntervalStrategy {
    open override fun getNextIntervalMs(count: Int): Long {
        return this.interval * int64(count)
    }

}

public open class PollingFunctor<T>(private val taskFn: () -> XPromise<T>, private val checkResult: (Result<T>) -> Result<PollingStep>, private val options: PollingOptions) {
    private var retriesCounter: Int = 0
    private val startTimeMs: Long = int64(YSDate.now())
    open fun poll(): XPromise<T> {
        if (this.options.cancellationToken?.isCancelled() ?: false) {
            return reject<T>(PollingError("Polling cancelled"))
        }
        val promise = this.taskFn().flatBoth(__LBL__Polling_1@ {
            res: T ->
            return@__LBL__Polling_1 this.nextStep(resultValue(res))
        }
, __LBL__Polling_2@ {
            err: YSError ->
            return@__LBL__Polling_2 this.nextStep(resultError(err))
        })
        return promise
    }

    open fun nextStep(res: Result<T>): XPromise<T> {
        val nextStepResult = this.checkResult(res)
        if (nextStepResult.isError()) {
            return reject<T>(nextStepResult.getError())
        }
        val nextStep = nextStepResult.getValue()
        if (nextStep == PollingStep.done) {
            return toPromise<T>(res)
        }
        return this.retry()
    }

    private fun retry(): XPromise<T> {
        this.retriesCounter = this.retriesCounter + 1
        if (this.options.retries != null && this.retriesCounter > this.options.retries!!) {
            return reject<T>(PollingError("Maximum retries count reached"))
        }
        val elapsedTimeMs = int64(YSDate.now()) - this.startTimeMs
        if (this.options.timeoutMs != null && elapsedTimeMs > this.options.timeoutMs!!) {
            return reject<T>(PollingError("Timeout reached"))
        }
        val delayMs = this.options.nextIntervalStrategy?.getNextIntervalMs(this.retriesCounter) ?: int64(0)
        return delayed(getVoid(), delayMs).flatThen( {
            _ ->
            this.poll()
        })
    }

}

