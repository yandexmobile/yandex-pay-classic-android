// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM busilogics/card-binding-service.ts >>>

package com.yandex.xplat.yandex.pay

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*

public interface CardDataCipher {
    fun encrypt(data: String): XPromise<CardDataCipherResult>
}

public open class CardDataCipherResult(val dataEncryptedBase64: String, val hashAlgorithm: String) {
}

public open class CardBindingInfo(val cardId: String, val rrn: String?) {
}

public open class CardBindingService(private val payer: Payer, private val serviceToken: String, private val serializer: JSONSerializer, private val cardDataCipher: CardDataCipher, private val mobileBackendApi: MobileBackendApi, private val diehardBackendAPI: DiehardBackendApi, private val regionId: Int, private val pollingConfig: CheckPaymentPollingConfig = CheckPaymentPollingConfig.defaultConfig()) {
    private var cancellationToken: CancellationToken? = null
    open fun bind(card: NewCard, callback: ChallengeCallback): XPromise<CardBindingInfo> {
        this.cancellationToken = CancellationToken()
        return YandexPayAnalytics.events.bindNewCard().traceExecution(this.innerBind(card, callback))
    }

    private fun innerBind(card: NewCard, callback: ChallengeCallback): XPromise<CardBindingInfo> {
        if (this.payer.oauthToken == null) {
            return reject<CardBindingInfo>(CardBindingServiceError.emptyOAuthToken())
        }
        val cardData = this.serialize(card)
        if (cardData.isError()) {
            return reject<CardBindingInfo>(cardData.getError())
        }
        val pollingHandler = CheckBindingPaymentPollingHandler(callback)
        return this.cardDataCipher.encrypt(cardData.getValue()).flatThen(__LBL__CardBindingService_1@ {
            cardDataCipherResult: CardDataCipherResult ->
            if (this.isCancelled()) {
                return@__LBL__CardBindingService_1 reject<NewCardBindingResponse>(CardBindingServiceError.cancelled())
            }
            val request = NewCardBindingRequest(this.payer.oauthToken!!, this.serviceToken, cardDataCipherResult.hashAlgorithm, cardDataCipherResult.dataEncryptedBase64, this.regionId)
            return@__LBL__CardBindingService_1 YandexPayAnalytics.events.bindNewCardBinding().traceExecution(this.diehardBackendAPI.newCardBinding(request))
        }).flatThen(__LBL__CardBindingService_2@ {
            response: NewCardBindingResponse ->
            if (this.isCancelled()) {
                return@__LBL__CardBindingService_2 reject<VerifyBindingResponse>(CardBindingServiceError.cancelled())
            }
            val request = VerifyBindingRequest(response.bindingId)
            YandexPayAnalytics.events.bindNewCardBindingCompleted().report()
            return@__LBL__CardBindingService_2 YandexPayAnalytics.events.bindNewCardVerify().traceExecution(this.mobileBackendApi.verifyBinding(request))
        }).flatThen(__LBL__CardBindingService_3@ {
            response: VerifyBindingResponse ->
            if (this.isCancelled()) {
                return@__LBL__CardBindingService_3 reject<CardBindingInfo>(CardBindingServiceError.cancelled())
            }
            YandexPayAnalytics.events.bindNewCardVerifyCompleted().report()
            return@__LBL__CardBindingService_3 YandexPayAnalytics.events.bindNewCardPollingStatus().traceExecution(this.performPolling(response.purchaseToken, pollingHandler))
        })
    }

    open fun isCancelled(): Boolean {
        return this.cancellationToken?.isCancelled() == true
    }

    open fun cancel(): Unit {
        this.cancellationToken?.cancel()
    }

    private fun serialize(card: NewCard): Result<String> {
        val cardData = MapJSONItem().putString("cvn", card.cvn).putString("card_number", card.cardNumber).putString("expiration_year", card.expirationYear).putString("expiration_month", card.expirationMonth)
        return this.serializer.serialize(cardData)
    }

    private fun performPolling(token: String, pollingHandler: CheckBindingPaymentPolling): XPromise<CardBindingInfo> {
        if (this.isCancelled()) {
            return reject<CardBindingInfo>(CardBindingServiceError.cancelled())
        }
        val options = PollingOptions(null, PollingFixedIntervalStrategy(this.pollingConfig.intervalMs), this.pollingConfig.timeoutMs, this.cancellationToken)
        return startSuccessResultPolling( {
             ->
            this.diehardBackendAPI.checkBindingPayment(CheckPaymentRequest(token))
        }
,  {
            response: CheckBindingPaymentResponse ->
            pollingHandler.checkResponse(response)
        }
, options).then( {
            response: CheckBindingPaymentResponse ->
            CardBindingInfo(response.paymentMethodId, response.rrn)
        }).flatCatch(__LBL__CardBindingService_4@ {
            error ->
            Log.error("Check status polling failed: ${error.message}")
            return@__LBL__CardBindingService_4 if (error.message == "Polling cancelled") reject(CardBindingServiceError.cancelled()) else reject(error)
        })
    }

}

