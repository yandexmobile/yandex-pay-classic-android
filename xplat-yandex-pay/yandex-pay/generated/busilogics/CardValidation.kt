// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM busilogics/card-validation.ts >>>

package com.yandex.xplat.yandex.pay

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*

public open class CardValidationError(val customErrorMessage: String?) {
    companion object {
        @JvmStatic val default: CardValidationError = CardValidationError(null)
        @JvmStatic
        open fun custom(customErrorMessage: String?): CardValidationError {
            return CardValidationError(customErrorMessage)
        }

    }
}

public abstract class CardField {
    companion object {
        @JvmStatic
        open fun expirationDate(month: String, year: String): CardExpirationDateField {
            return CardExpirationDateField(month, year)
        }

        @JvmStatic
        open fun number(value: String): CardNumberField {
            return CardNumberField(value)
        }

        @JvmStatic
        open fun cvn(value: String): CardCvnField {
            return CardCvnField(value)
        }

        @JvmStatic
        open fun email(value: String): CardEmailField {
            return CardEmailField(value)
        }

        @JvmStatic
        open fun phone(value: String): CardPhoneField {
            return CardPhoneField(value)
        }

    }
}

public open class CardNumberField(val value: String): CardField() {
}

public open class CardExpirationDateField(val month: String, val year: String): CardField() {
}

public open class CardCvnField(val value: String): CardField() {
}

public open class CardEmailField(val value: String): CardField() {
}

public open class CardPhoneField(val value: String): CardField() {
}

public abstract class CardFieldValidator<T: CardField>() {
    abstract fun validate(`field`: T): CardValidationError?
    open fun composite(): CompositeCardFieldValidator<T> {
        return CompositeCardFieldValidator<T>().addValidator(this)
    }

}

public open class CompositeCardFieldValidator<T: CardField>(): CardFieldValidator<T>() {
    private var validators: YSArray<CardFieldValidator<T>> = mutableListOf()
    open fun addValidator(validator: CardFieldValidator<T>): CompositeCardFieldValidator<T> {
        this.validators.add(validator)
        return this
    }

    open override fun validate(`field`: T): CardValidationError? {
        for (validator in this.validators) {
            val result = validator.validate(`field`)
            if (result != null) {
                return result
            }
        }
        return null
    }

}

public open class SuccessCardFieldValidator<T: CardField>(): CardFieldValidator<T>() {
    open override fun validate(`field`: T): CardValidationError? {
        return null
    }

}

public open class FailureCardFieldValidator<T: CardField>(private val error: CardValidationError): CardFieldValidator<T>() {
    open override fun validate(`field`: T): CardValidationError? {
        return this.error
    }

}

public open class DefaultCardNumberValidator(): CardFieldValidator<CardNumberField>() {
    open override fun validate(`field`: CardNumberField): CardValidationError? {
        if (stringToInt64(`field`.value) == null) {
            return CardValidationError.default
        }
        return null
    }

}

public open class LengthCardNumberValidator(private val lengths: YSArray<Int>): CardFieldValidator<CardNumberField>() {
    open override fun validate(`field`: CardNumberField): CardValidationError? {
        if (this.lengths.contains(`field`.value.length)) {
            return null
        }
        return CardValidationError.default
    }

    companion object {
        @JvmStatic
        open fun validateCardLength(cardNumber: String): Boolean {
            val cardType = CardType.cardTypeFromCardNumber(cardNumber)
            val validator = LengthCardNumberValidator.withCardNetwork(cardType.cardNetwork)
            return validator.validate(CardField.number(cardNumber)) == null
        }

        @JvmStatic
        open fun withCardNetwork(cardNetwork: CardNetworks?): LengthCardNumberValidator {
            val cardType = CardType.cardTypeByNetwork(cardNetwork)
            return LengthCardNumberValidator(cardType.validLengths)
        }

    }
}

public open class LuhnCardNumberValidator(): CardFieldValidator<CardNumberField>() {
    open override fun validate(`field`: CardNumberField): CardValidationError? {
        return if (checkLuhn(`field`.value)) null else CardValidationError.default
    }

}

public open class DefaultCardExpirationDateValidator(private val today: YSDate = YSDate()): CardFieldValidator<CardExpirationDateField>() {
    open override fun validate(`field`: CardExpirationDateField): CardValidationError? {
        val currentYear = this.today.getFullYear() % 100
        val currentMonth = this.today.getMonth() + 1
        val cardYear = stringToInt32(`field`.year) ?: 0
        if (cardYear < currentYear || cardYear > currentYear + 50) {
            return CardValidationError.default
        }
        val cardMonth = stringToInt32(`field`.month) ?: 0
        if (cardMonth > 12 || cardMonth < 1) {
            return CardValidationError.default
        }
        if (cardYear == currentYear && cardMonth < currentMonth) {
            return CardValidationError.default
        }
        return null
    }

}

public open class DefaultCardCvnValidator(): CardFieldValidator<CardCvnField>() {
    open override fun validate(`field`: CardCvnField): CardValidationError? {
        if (stringToInt32(`field`.value) == null) {
            return CardValidationError.default
        }
        return null
    }

}

public open class LengthCardCvnValidator(private val length: Int): CardFieldValidator<CardCvnField>() {
    open override fun validate(`field`: CardCvnField): CardValidationError? {
        if (`field`.value.length != this.length) {
            return CardValidationError.default
        }
        return null
    }

    companion object {
        @JvmStatic
        open fun withCardNetwork(cardNetwork: CardNetworks?): LengthCardCvnValidator {
            val cardType = CardType.cardTypeByNetwork(cardNetwork)
            return LengthCardCvnValidator(cardType.cvvLength)
        }

    }
}

public open class DefaultCardEmailValidator(private val callback: (String) -> CardValidationError?): CardFieldValidator<CardEmailField>() {
    open override fun validate(`field`: CardEmailField): CardValidationError? {
        return this.callback(`field`.value)
    }

}

public open class DefaultCardPhoneValidator(private val callback: (String) -> CardValidationError?): CardFieldValidator<CardPhoneField>() {
    open override fun validate(`field`: CardPhoneField): CardValidationError? {
        return this.callback(`field`.value)
    }

}

public open class CardMinExpirationDateValidator private constructor(private val minExpirationYear: Int, private val minExpirationMonth: Int, private val validationError: CardValidationError): CardFieldValidator<CardExpirationDateField>() {
    open override fun validate(`field`: CardExpirationDateField): CardValidationError? {
        val cardYear = stringToInt32(`field`.year) ?: 0
        if (cardYear < this.minExpirationYear) {
            return this.validationError
        }
        if (cardYear == this.minExpirationYear) {
            val cardMonth = stringToInt32(`field`.month) ?: 0
            if (cardMonth < this.minExpirationMonth) {
                return this.validationError
            }
        }
        return null
    }

    companion object {
        @JvmStatic
        open fun create(minExpirationYear: Int, minExpirationMonth: Int, validationError: CardValidationError): CardMinExpirationDateValidator {
            if (minExpirationMonth < 1 || minExpirationMonth > 12) {
                throw CardValidationException("Invalid month specified: ${minExpirationMonth}")
            }
            return CardMinExpirationDateValidator(minExpirationYear % 100, minExpirationMonth, validationError)
        }

    }
}

public open class CardBinRangeValidator(private val ranges: YSArray<CardBinRange>, private val validationError: CardValidationError): CardFieldValidator<CardNumberField>() {
    open override fun validate(`field`: CardNumberField): CardValidationError? {
        if (`field`.value.length < 1) {
            return this.validationError
        }
        val binString = `field`.value.substring(0, CardBinRangeValidator.binLength)
        val bin = stringToInt32(binString)
        if (bin == null) {
            return this.validationError
        }
        var isInRange = false
        if (binString.length < CardBinRangeValidator.binLength) {
            val diff = CardBinRangeValidator.binLength - binString.length
            for (range in this.ranges) {
                if (this.checkPrefixMatches(range, bin, diff)) {
                    isInRange = true
                    break
                }
            }
        } else {
            for (range in this.ranges) {
                if (bin < range.from) {
                    break
                }
                if (bin >= range.from && bin <= range.to) {
                    isInRange = true
                    break
                }
            }
        }
        return if (isInRange) null else this.validationError
    }

    private fun checkPrefixMatches(range: CardBinRange, bin: Int, diff: Int): Boolean {
        var from = range.from
        var to = range.to
        var pow = diff
        while (pow > 0) {
            from /= 10
            to /= 10
            pow -= 1
        }
        return bin >= from && bin <= to
    }

    companion object {
        @JvmStatic val binLength: Int = 8
    }
}

public open class CardBinRangeBuilder() {
    private val ranges: YSArray<CardBinRange>
    init {
        this.ranges = mutableListOf()
    }
    open fun addRange(from: String, to: String): CardBinRangeBuilder {
        val rangeFrom = this.tryParse(from)
        val rangeTo = this.tryParse(to)
        if (rangeTo < rangeFrom) {
            throw CardValidationException("Invalid range specified: ${to} < ${from}")
        }
        this.ranges.add(CardBinRange(rangeFrom, rangeTo))
        return this
    }

    open fun build(): YSArray<CardBinRange> {
        return this.ranges.sort( {
            a, b ->
            a.from - b.from
        })
    }

    private fun tryParse(value: String): Int {
        val binLength = CardBinRangeValidator.binLength
        val result = if (value.length == binLength) stringToInt32(value, 10) else null
        if (result == null) {
            throw CardValidationException("Card BIN must contain exactly ${binLength} digits")
        }
        return result!!
    }

}

public open class CardBinRange(val from: Int, val to: Int) {
}

public open class CardValidationException(message: String): YSError(message) {
}

public open class CardValidators(val numberValidator: CardFieldValidator<CardNumberField>, val expirationDateValidator: CardFieldValidator<CardExpirationDateField>, val cvnValidator: CardFieldValidator<CardCvnField>, val emailValidator: CardFieldValidator<CardEmailField>, val phoneValidator: CardFieldValidator<CardPhoneField>) {
}

