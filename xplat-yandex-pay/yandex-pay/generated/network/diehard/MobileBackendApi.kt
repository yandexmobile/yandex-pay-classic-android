// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM network/diehard/mobile-backend-api.ts >>>

package com.yandex.xplat.yandex.pay

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*

public open class MobileBackendApiError(val error: MobileBackendErrorResponse): NetworkServiceError(mobileBackendStatusToKind(error.code), ExternalErrorTrigger.mobile_backend, error.code, "Mobile Backend Error: code - ${error.code}, status - ${error.status} in request ${error.reqID}: ${error.message ?: "empty message"}") {
    open override fun convertToExternalError(): ExternalError {
        return ExternalError(this.kind, this.trigger, this.code, this.error.status, this.message)
    }

}

public open class MobileBackendApi(private val networkService: NetworkService) {
    open fun verifyBinding(request: VerifyBindingRequest): XPromise<VerifyBindingResponse> {
        return this.networkService.performRequest(request,  {
            item ->
            VerifyBindingResponse.fromJsonItem(item)
        })
    }

    companion object {
        @JvmStatic
        open fun create(network: Network, serializer: JSONSerializer, serviceToken: String, authorizationProvider: () -> XPromise<MobileBackendAuthorization?>, platform: ClientPlatform, version: String, forceCVV: Boolean, passportToken: String?): MobileBackendApi {
            val interceptor = MobileBackendNetworkInterceptor(authorizationProvider, serviceToken)
            val versionHeadersInterceptor = MobileBackendVersionHeadersInterceptor(platform, version)
            val additionalHeadersInterceptor = MobileBackendAdditionalHeadersInterceptor(forceCVV)
            val passportHeadersInterceptor = PassportHeaderInterceptor(passportToken)
            val authorizedNetwork = NetworkIntermediate(network, mutableListOf(interceptor, versionHeadersInterceptor, additionalHeadersInterceptor, passportHeadersInterceptor))
            val errorProcessor = MobileBackendErrorProcessor()
            val networkService = NetworkService(authorizedNetwork, serializer, errorProcessor)
            return MobileBackendApi(networkService)
        }

    }
}

public open class MobileBackendErrorProcessor: NetworkServiceErrorProcessor {
    open override fun extractError(errorBody: JSONItem): NetworkServiceError? {
        val errorResponse = MobileBackendErrorResponse.fromJsonItem(errorBody)
        if (errorResponse.isError()) {
            return null
        }
        return MobileBackendApiError(errorResponse.getValue())
    }

    open override fun validateResponse(body: JSONItem): NetworkServiceError? {
        return null
    }

    open override fun wrapError(error: NetworkServiceError): NetworkServiceError {
        if (error is MobileBackendApiError) {
            return error
        }
        return error.errorWithTrigger(ExternalErrorTrigger.mobile_backend)
    }

}

