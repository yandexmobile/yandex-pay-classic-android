// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM network/diehard/network-service.ts >>>

package com.yandex.xplat.yandex.pay

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*

public interface NetworkServiceErrorProcessor {
    fun extractError(errorBody: JSONItem): NetworkServiceError?
    fun validateResponse(body: JSONItem): NetworkServiceError?
    fun wrapError(error: NetworkServiceError): NetworkServiceError
}

public open class NetworkService(private val network: Network, private val serializer: JSONSerializer, private val errorProcessor: NetworkServiceErrorProcessor) {
    open fun <T> performRequest(request: NetworkRequest, parse: (JSONItem) -> Result<T>): XPromise<T> {
        return this.network.executeRaw(request).flatCatch( {
            error ->
            this.wrappedReject(NetworkServiceError.transportFailure(error))
        }).flatThen(__LBL__NetworkService_1@ {
            response: NetworkResponse ->
            if (!response.isSuccessful()) {
                return@__LBL__NetworkService_1 this.wrappedReject(this.extractError(response))
            }
            if (response.body() == null) {
                return@__LBL__NetworkService_1 this.wrappedReject(NetworkServiceError.noResponseBody())
            }
            return@__LBL__NetworkService_1 toPromise<T>(this.extractResponse(response.body()!!.string(), parse))
        })
    }

    private fun extractError(response: NetworkResponse): NetworkServiceError {
        if (response.body() == null) {
            return NetworkServiceError.badStatusCode(response.code(), "empty body")
        }
        val bodyString = response.body()!!.string()
        val deserialized = this.serializer.deserialize(bodyString)
        if (deserialized.isError()) {
            return NetworkServiceError.badStatusCode(response.code(), "Failed to parse error body: \"${bodyString}\", error: \"${deserialized.getError().message}\"")
        }
        val json = deserialized.getValue()
        val error = this.errorProcessor.extractError(json)
        if (error == null) {
            return NetworkServiceError.badStatusCode(response.code(), "Failed to extract error body: \"${bodyString}\", json: \"${JSONItemGetDebugDescription(json)}\"")
        }
        return error!!
    }

    private fun <T> extractResponse(bodyString: String, parse: (JSONItem) -> Result<T>): Result<T> {
        val deserialized = this.serializer.deserialize(bodyString)
        if (deserialized.isError()) {
            return this.wrappedResultError(NetworkServiceError.unableToDeserialize(deserialized.getError()))
        }
        val json = deserialized.getValue()
        val error = this.errorProcessor.validateResponse(json)
        if (error != null) {
            return this.wrappedResultError(error)
        }
        val parsed = parse(json)
        if (parsed.isError()) {
            return this.wrappedResultError(NetworkServiceError.unableToParse(json, parsed.getError()))
        }
        return resultValue(parsed.getValue())
    }

    private fun <T> wrappedReject(reason: NetworkServiceError): XPromise<T> {
        return reject(this.errorProcessor.wrapError(reason))
    }

    private fun <T> wrappedResultError(error: NetworkServiceError): Result<T> {
        return resultError(this.errorProcessor.wrapError(error))
    }

}

