// <<< AUTOGENERATED BY YANDEX.SCRIPT FROM network/yandex-pay-backend/response-processor.ts >>>

package com.yandex.xplat.yandex.pay

import com.yandex.xplat.common.*
import com.yandex.xplat.eventus.common.*

public open class ResponseProcessor(private val serializer: JSONSerializer) {
    open fun <T> extractResponse(requestTag: String, response: NetworkResponse, parse: (JSONItem) -> Result<T>): XPromise<T> {
        return this.extractAndValidateResponse(requestTag, response,  {
            json ->
            this.validateResponse(json, requestTag)
        }
, parse)
    }

    open fun <T> extractUnvalidatedResponse(requestTag: String, response: NetworkResponse, parse: (JSONItem) -> Result<T>): XPromise<T> {
        return this.extractAndValidateResponse(requestTag, response,  {
            _ ->
            null
        }
, parse)
    }

    private fun validateResponse(json: JSONItem, requestTag: String): String? {
        val mapResponse = json.castAsMapJSONItem()
        if (mapResponse == null) {
            return "Map expected as response of request ${requestTag}"
        }
        val status = mapResponse!!.getString("status")
        val code = mapResponse!!.getInt32("code")
        if (status == null || code == null) {
            return "Either Status or Code field is absent or of improper type in response on ${requestTag}"
        }
        return null
    }

    private fun <T> extractAndValidateResponse(requestTag: String, response: NetworkResponse, validation: (JSONItem) -> String?, parse: (JSONItem) -> Result<T>): XPromise<T> {
        val bodyString = undefinedToNull(response.body()?.string())
        if (bodyString == null) {
            return reject(TransportError.payloadError("No payload in response on ${requestTag}"))
        }
        val deserialized = this.serializer.deserialize(bodyString)
        if (deserialized.isError()) {
            val error = deserialized.getError()
            return reject(TransportError.serializationError("Error deserializing response on ${requestTag}: ${error.message}", error))
        }
        val json = deserialized.getValue()
        val dataFormatError = validation(json)
        if (dataFormatError != null) {
            return reject(TransportError.dataFormatError(dataFormatError!!))
        }
        val parsed = parse(json)
        if (parsed.isError()) {
            return reject(parsed.getError())
        } else {
            return if (response.isSuccessful()) resolve(parsed.getValue()) else reject(TransportError.badStatusCode("Bad status code on ${requestTag}: ${response.code()}"))
        }
    }

}

